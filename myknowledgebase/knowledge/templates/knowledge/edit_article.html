<!-- knowledge/templates/knowledge/edit_article.html -->
{% extends 'knowledge/base.html' %}
{% load widget_tweaks %}

{% block content %}
  <h2>Edit an Existing KB Article</h2>
  <form method="POST" id="kbEntryForm">
    {% csrf_token %}
    {% for field in form %}
        {% if not field.name == "meta_data" %}
            <div class="form-group">
        {% if field.name == "article" %}
            <label for="quillEditor">{{ field.label }}</label>
            <div id="quillEditor" style="height: 200px;">{{ field.value }}</div>
            {{ field|attr:"style:display:none;" }}
        {% else %}
            <label for="{{ field.id_for_label }}">{{ field.label }}</label>
            {{ field|add_class:"form-control" }}
        {% endif %}
        {% endif %}
            </div>
    {% endfor %}

    <div class="form-group">
        <label for="metatagLookup">Lookup/Add Metatag:</label>
        <input type="text" id="metatagLookup" class="form-control" placeholder="Type to search or add a new tag..." />
    </div>
    
    <div class="form-group">
        <label>Metadata Tags:</label>
        <div id="selectedMetatags"></div>
        <input type="hidden" name="meta_data" id="meta_data_input">
    </div>
    <br>
    {{ article.modified_date|date }}
    <button type="submit" class="btn btn-danger">Save Changes</button>
    <button type="button" class="btn btn-primary" onclick="window.history.back();">Go Back (Do Not Save)</button>
  </form>

  {% if form.errors %}
  <div class="alert alert-danger">
    <ul>
      {% for field, errors in form.errors.items %}
        {% for error in errors %}
          <li><strong>{{ field }}:</strong> {{ error|escape }}</li>
        {% endfor %}
      {% endfor %}
    </ul>
  </div>
  {% endif %}

{% endblock %}

{% block extra_js %}
<script>
    // Wait until the document content is fully loaded before running the script
    $(document).ready(function() {

    // Initialize Quill editor with custom toolbar options   
    var quill = new Quill('#quillEditor', {
      theme: 'snow',
      modules: {
        toolbar: ToolbarOptions,
      },
    });

    // Find the quillEditor div and traverse up to its closest parent with class "form-group"
    // We need this to add the 'is-valid' and 'is-invalid classes' as it is created dynamically
    var quillEditorFormGroup = $('#quillEditor').closest('.form-group');
    // Assign an ID to this form-group div
    quillEditorFormGroup.attr('id', 'quillEditorFormGroup');
    var formGroup = $("#quillEditorFormGroup");

    // Populate the editor with the current article content
    quill.root.innerHTML = "{{ article.article|escapejs }}";

    
    // Using jQuery to get the article and title objects
    var article = $('textarea[name=article]');
    var title = $('#id_title');

    // Update the value of the hidden article textarea whenever the Quill content changes
    // Also added some checks as user types and add valid/invalid classes
    quill.on('text-change', function() {
        var text = quill.getText().trim();
        var length = text.length;
        if(length >= 10) {
            formGroup.removeClass("is-invalid").addClass("is-valid");
        } else {
            formGroup.removeClass("is-valid").addClass("is-invalid");
        }
        // Set the article text to the contents of the Quill Editor
        article.val(quill.root.innerHTML);
        });


    // Focus on the Title
    title.focus();

    // Listener for Title
    title.on("input", function() {
        var input=$(this);
        var title_length=input.val().length;
        if(title_length>=3){
            input.removeClass("is-invalid").addClass("is-valid");
        }
        else{
            input.removeClass("is-valid").addClass("is-invalid");
        }
    });


    // References to important DOM elements
    const meta_data_input = $('#meta_data_input');
    const metatags = {{ all_tags_json|safe }};
    const selectedMetatags = $('#selectedMetatags');
    const metatagLookup = $('#metatagLookup');

    console.log(meta_data_input, selectedMetatags);

    // Initialize the list of selected metatags based on the current article's tags
    const initialMetatags = "{{ associated_metatags|join:','|default:''|safe }}".split(',');
    initialMetatags.forEach(tag => {
        addMetatagToSelected(tag, selectedMetatags, meta_data_input);
    });

    // Create and set up the dropdown for metatag lookup using jQuery
    const metatagDropdown = $('<div>').attr('id', 'metatagDropdown');
        metatagLookup.after(metatagDropdown);
    
    // Handle form submission: update hidden input and submit form
    const form = $('#kbEntryForm');
    form.on('submit', function(event) {
        event.preventDefault();
        // Some basic validation to ensure Title and Body are not empty
        var titleText=title.val();
        if(titleText.trim()==='')
        {
          title.addClass('is-invalid').focus();
          alertify.error("Article Title cannot be blank");
          return false;
        }
        // Title needs to be more than 3 characters
        if(titleText.length < 3)
        {
          title.focus();
          alertify.error("Article Title should be at least 3 characters");
          return false;
        }
        if(titleText.length > 255)
        {
          title.focus();
          alertify.error("Article Title should not exceed 255 characters");
          return false;
        }
        // Article cannot be blank
        if(article.val().trim()==='' || article.val()==='<p><br></p>')
        {
          formGroup.removeClass("is-valid").addClass("is-invalid");
          alertify.error("Article Body cannot be blank");
          //console.log("Article content:"+article.val()); // article will contain <p><br><p> if it is empty
          return false;
        }
        if(stripTags(article.val()).trim().length < 10)
        {
            formGroup.removeClass("is-valid").addClass("is-invalid");
            alertify.error("Article Body should contain at least 10 characters");
            return false;
        }
        updateMetaDataInput(selectedMetatags, meta_data_input);  // Update the hidden input before submitting
        form.off('submit');
        form.submit();
    });
    
    // Handle metatag lookup: show dropdown on keyup, prevent form submission on Enter
    metatagLookup.keydown(function(event) {
        console.log("Key pressed:", event.key);
        if (event.key === "Enter") {
            event.preventDefault(); // Stop the Enter key from submitting the form
            
            let value = metatagLookup.val().trim();
            
            // Check if the value matches any tag in the dropdown
            let dropdownMatches = metatagDropdown.children().map(function() {
                return $(this).text().trim();
            }).get();

            // If the typed tag matches an existing tag or a dropdown option, add it
            if (value && (metatags.includes(value) || dropdownMatches.includes(value))) {
                addMetatagToSelected(value, selectedMetatags, meta_data_input);
            } 
            // Otherwise, treat it as a new tag
            else if (value) {
                metatags.push(value);  // Add to mock data
                addMetatagToSelected(value, selectedMetatags, meta_data_input);
            }

            metatagDropdown.empty();  // Clear the dropdown
            metatagLookup.val('');  // Clear the input
        }
    });


    metatagLookup.keyup(function(event) {
        if (event.key !== "Enter") {
            // Clear the dropdown first
            metatagDropdown.empty();
            
            // Filter the metatags based on user input
            let value = metatagLookup.val().trim();
            let matches = metatags.filter(tag => tag.includes(value));
            
            // Populate the dropdown with matching tags
            matches.forEach(match => {
                let tagElement = $('<div>').text(match);
                tagElement.click(function() {
                    addMetatagToSelected(match, selectedMetatags, meta_data_input);
                    metatagDropdown.empty();  // Clear the dropdown
                    metatagLookup.val('');  // Clear the input
                    updateMetaDataInput(selectedMetatags, meta_data_input);  // Update the hidden input after adding a tag
                });
                metatagDropdown.append(tagElement);
            });
        } else {
            let value = metatagLookup.val().trim();
            if (!metatags.includes(value)) {
                metatags.push(value);  // Add to mock data
                addMetatagToSelected(value, selectedMetatags,meta_data_input);
            }
            metatagDropdown.empty();  // Clear the dropdown
            metatagLookup.val('');  // Clear the input
        }
    });

    });
  </script>
{% endblock %}